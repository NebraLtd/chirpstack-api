# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: chirpstack-api/gw/gw.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    Dict,
    List,
)

import betterproto

from .. import common as _common__


class DownlinkTiming(betterproto.Enum):
    IMMEDIATELY = 0
    """Send the downlink immediately."""

    DELAY = 1
    """Send downlink at the given delay (based on provided context)."""

    GPS_EPOCH = 2
    """Send at given GPS epoch value."""


class FineTimestampType(betterproto.Enum):
    NONE = 0
    """No fine-timestamp available."""

    ENCRYPTED = 1
    """Encrypted fine-timestamp."""

    PLAIN = 2
    """Plain fine-timestamp."""


class CrcStatus(betterproto.Enum):
    NO_CRC = 0
    """No CRC."""

    BAD_CRC = 1
    """Bad CRC."""

    CRC_OK = 2
    """CRC OK."""


class TxAckStatus(betterproto.Enum):
    IGNORED = 0
    """Ignored (when a previous item was already emitted)."""

    OK = 1
    """Packet has been programmed for downlink."""

    TOO_LATE = 2
    """
    Rejected because it was already too late to program this packet for
    downlink.
    """

    TOO_EARLY = 3
    """Rejected because downlink packet timestamp is too much in advance."""

    COLLISION_PACKET = 4
    """
    Rejected because there was already a packet programmed in requested
    timeframe.
    """

    COLLISION_BEACON = 5
    """
    Rejected because there was already a beacon planned in requested timeframe.
    """

    TX_FREQ = 6
    """
    Rejected because requested frequency is not supported by TX RF chain.
    """

    TX_POWER = 7
    """Rejected because requested power is not supported by gateway."""

    GPS_UNLOCKED = 8
    """Rejected because GPS is unlocked, so GPS timestamp cannot be used."""

    QUEUE_FULL = 9
    """Downlink queue is full."""

    INTERNAL_ERROR = 10
    """Internal error."""


class ConnStateState(betterproto.Enum):
    OFFLINE = 0
    ONLINE = 1


@dataclass(eq=False, repr=False)
class Modulation(betterproto.Message):
    lora: "LoRaModulationInfo" = betterproto.message_field(3, group="parameters")
    """LoRa modulation information."""

    fsk: "FskModulationInfo" = betterproto.message_field(4, group="parameters")
    """FSK modulation information."""

    lr_fhss: "LrfhssModulationInfo" = betterproto.message_field(5, group="parameters")
    """LR-FHSS modulation information."""


@dataclass(eq=False, repr=False)
class UplinkTxInfo(betterproto.Message):
    frequency: int = betterproto.uint32_field(1)
    """Frequency (Hz)."""

    modulation: "_common__.Modulation" = betterproto.enum_field(2)
    """Modulation."""

    lora_modulation_info: "LoRaModulationInfo" = betterproto.message_field(
        3, group="modulation_info"
    )
    """LoRa modulation information."""

    fsk_modulation_info: "FskModulationInfo" = betterproto.message_field(
        4, group="modulation_info"
    )
    """FSK modulation information."""

    lr_fhss_modulation_info: "LrfhssModulationInfo" = betterproto.message_field(
        5, group="modulation_info"
    )
    """LR-FHSS modulation information."""


@dataclass(eq=False, repr=False)
class LoRaModulationInfo(betterproto.Message):
    bandwidth: int = betterproto.uint32_field(1)
    """Bandwidth."""

    spreading_factor: int = betterproto.uint32_field(2)
    """Speading-factor."""

    code_rate: str = betterproto.string_field(3)
    """Code-rate."""

    polarization_inversion: bool = betterproto.bool_field(4)
    """Polarization inversion."""


@dataclass(eq=False, repr=False)
class FskModulationInfo(betterproto.Message):
    frequency_deviation: int = betterproto.uint32_field(1)
    """Frequency deviation."""

    datarate: int = betterproto.uint32_field(2)
    """FSK datarate (bits / sec)."""


@dataclass(eq=False, repr=False)
class LrfhssModulationInfo(betterproto.Message):
    operating_channel_width: int = betterproto.uint32_field(1)
    """Operating channel width (OCW) in Hz."""

    code_rate: str = betterproto.string_field(2)
    """Code-rate."""

    grid_steps: int = betterproto.uint32_field(3)
    """Hopping grid number of steps."""


@dataclass(eq=False, repr=False)
class EncryptedFineTimestamp(betterproto.Message):
    aes_key_index: int = betterproto.uint32_field(1)
    """AES key index used for encrypting the fine timestamp."""

    encrypted_ns: bytes = betterproto.bytes_field(2)
    """
    Encrypted 'main' fine-timestamp (ns precision part of the timestamp).
    """

    fpga_id: bytes = betterproto.bytes_field(3)
    """FPGA ID."""


@dataclass(eq=False, repr=False)
class PlainFineTimestamp(betterproto.Message):
    time: datetime = betterproto.message_field(1)
    """Full timestamp."""


@dataclass(eq=False, repr=False)
class GatewayStats(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    ip: str = betterproto.string_field(9)
    """Gateway IP."""

    time: datetime = betterproto.message_field(2)
    """Gateway time."""

    location: "_common__.Location" = betterproto.message_field(3)
    """Gateway location."""

    config_version: str = betterproto.string_field(4)
    """
    Gateway configuration version (this maps to the config_version sent by LoRa
    Server to the gateway).
    """

    rx_packets_received: int = betterproto.uint32_field(5)
    """Number of radio packets received."""

    rx_packets_received_ok: int = betterproto.uint32_field(6)
    """Number of radio packets received with valid PHY CRC."""

    tx_packets_received: int = betterproto.uint32_field(7)
    """Number of downlink packets received for transmission."""

    tx_packets_emitted: int = betterproto.uint32_field(8)
    """Number of downlink packets emitted."""

    meta_data: Dict[str, str] = betterproto.map_field(
        10, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """Additional gateway meta-data."""

    stats_id: bytes = betterproto.bytes_field(11)
    """Stats ID (UUID). Unique identifier for the gateway stats."""

    tx_packets_per_frequency: Dict[int, int] = betterproto.map_field(
        12, betterproto.TYPE_UINT32, betterproto.TYPE_UINT32
    )
    """Tx packets per frequency."""

    rx_packets_per_frequency: Dict[int, int] = betterproto.map_field(
        13, betterproto.TYPE_UINT32, betterproto.TYPE_UINT32
    )
    """Rx packets per frequency."""

    tx_packets_per_modulation: List["PerModulationCount"] = betterproto.message_field(
        14
    )
    """Tx packets per modulation parameters."""

    rx_packets_per_modulation: List["PerModulationCount"] = betterproto.message_field(
        15
    )
    """Rx packets per modulation parameters."""

    tx_packets_per_status: Dict[str, int] = betterproto.map_field(
        16, betterproto.TYPE_STRING, betterproto.TYPE_UINT32
    )
    """Tx packets per status."""


@dataclass(eq=False, repr=False)
class PerModulationCount(betterproto.Message):
    modulation: "Modulation" = betterproto.message_field(1)
    """Modulation."""

    count: int = betterproto.uint32_field(2)
    """Count."""


@dataclass(eq=False, repr=False)
class UplinkRxInfo(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    time: datetime = betterproto.message_field(2)
    """RX time (only set when the gateway has a GPS module)."""

    time_since_gps_epoch: timedelta = betterproto.message_field(3)
    """
    RX time since GPS epoch (only set when the gateway has a GPS module).
    """

    rssi: int = betterproto.int32_field(5)
    """RSSI."""

    lora_snr: float = betterproto.double_field(6)
    """LoRa SNR."""

    channel: int = betterproto.uint32_field(7)
    """Channel."""

    rf_chain: int = betterproto.uint32_field(8)
    """RF Chain."""

    board: int = betterproto.uint32_field(9)
    """Board."""

    antenna: int = betterproto.uint32_field(10)
    """Antenna."""

    location: "_common__.Location" = betterproto.message_field(11)
    """Location."""

    fine_timestamp_type: "FineTimestampType" = betterproto.enum_field(12)
    """Fine-timestamp type."""

    encrypted_fine_timestamp: "EncryptedFineTimestamp" = betterproto.message_field(
        13, group="fine_timestamp"
    )
    """Encrypted fine-timestamp data."""

    plain_fine_timestamp: "PlainFineTimestamp" = betterproto.message_field(
        14, group="fine_timestamp"
    )
    """Plain fine-timestamp data."""

    context: bytes = betterproto.bytes_field(15)
    """Gateway specific context."""

    uplink_id: bytes = betterproto.bytes_field(16)
    """
    Uplink ID (UUID bytes). Unique and random ID which can be used to correlate
    the uplink across multiple logs.
    """

    crc_status: "CrcStatus" = betterproto.enum_field(17)
    """CRC status."""


@dataclass(eq=False, repr=False)
class DownlinkTxInfo(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID. Deprecated: replaced by gateway_id in DownlinkFrame."""

    frequency: int = betterproto.uint32_field(5)
    """TX frequency (in Hz)."""

    power: int = betterproto.int32_field(6)
    """TX power (in dBm)."""

    modulation: "_common__.Modulation" = betterproto.enum_field(7)
    """Modulation."""

    lora_modulation_info: "LoRaModulationInfo" = betterproto.message_field(
        8, group="modulation_info"
    )
    """LoRa modulation information."""

    fsk_modulation_info: "FskModulationInfo" = betterproto.message_field(
        9, group="modulation_info"
    )
    """FSK modulation information."""

    board: int = betterproto.uint32_field(10)
    """The board identifier for emitting the frame."""

    antenna: int = betterproto.uint32_field(11)
    """The antenna identifier for emitting the frame."""

    timing: "DownlinkTiming" = betterproto.enum_field(12)
    """Timing defines the downlink timing to use."""

    immediately_timing_info: "ImmediatelyTimingInfo" = betterproto.message_field(
        13, group="timing_info"
    )
    """Immediately timing information."""

    delay_timing_info: "DelayTimingInfo" = betterproto.message_field(
        14, group="timing_info"
    )
    """Context based delay timing information."""

    gps_epoch_timing_info: "GpsEpochTimingInfo" = betterproto.message_field(
        15, group="timing_info"
    )
    """GPS Epoch timing information."""

    context: bytes = betterproto.bytes_field(16)
    """
    Gateway specific context. In case of a Class-A downlink, this contains a
    copy of the uplink context.
    """


@dataclass(eq=False, repr=False)
class ImmediatelyTimingInfo(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DelayTimingInfo(betterproto.Message):
    delay: timedelta = betterproto.message_field(1)
    """
    Delay (duration). The delay will be added to the gateway internal timing,
    provided by the context object.
    """


@dataclass(eq=False, repr=False)
class GpsEpochTimingInfo(betterproto.Message):
    time_since_gps_epoch: timedelta = betterproto.message_field(1)
    """Duration since GPS Epoch."""


@dataclass(eq=False, repr=False)
class UplinkFrame(betterproto.Message):
    phy_payload: bytes = betterproto.bytes_field(1)
    """PHYPayload."""

    tx_info: "UplinkTxInfo" = betterproto.message_field(2)
    """TX meta-data."""

    rx_info: "UplinkRxInfo" = betterproto.message_field(3)
    """RX meta-data."""


@dataclass(eq=False, repr=False)
class UplinkFrameSet(betterproto.Message):
    phy_payload: bytes = betterproto.bytes_field(1)
    """PHYPayload."""

    tx_info: "UplinkTxInfo" = betterproto.message_field(2)
    """TX meta-data."""

    rx_info: List["UplinkRxInfo"] = betterproto.message_field(3)
    """RX meta-data set."""


@dataclass(eq=False, repr=False)
class DownlinkFrame(betterproto.Message):
    phy_payload: bytes = betterproto.bytes_field(1)
    """PHYPayload. Deprecated: replaced by items."""

    tx_info: "DownlinkTxInfo" = betterproto.message_field(2)
    """TX meta-data. Deprecated: replaced by items."""

    token: int = betterproto.uint32_field(3)
    """Token (uint16 value). Deprecated: replaced by downlink_id."""

    downlink_id: bytes = betterproto.bytes_field(4)
    """Downlink ID (UUID)."""

    items: List["DownlinkFrameItem"] = betterproto.message_field(5)
    """
    Downlink frame items. This makes it possible to send multiple downlink
    opportunities to the gateway at once (e.g. RX1 and RX2 in LoRaWAN). The
    first item has the highest priority, the last the lowest. The gateway will
    emit at most one item.
    """

    gateway_id: bytes = betterproto.bytes_field(6)
    """Gateway ID."""


@dataclass(eq=False, repr=False)
class DownlinkFrameItem(betterproto.Message):
    phy_payload: bytes = betterproto.bytes_field(1)
    """PHYPayload."""

    tx_info: "DownlinkTxInfo" = betterproto.message_field(2)
    """TX meta-data."""


@dataclass(eq=False, repr=False)
class DownlinkTxAck(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    token: int = betterproto.uint32_field(2)
    """Token (uint16 value). Deprecated: replaced by downlink_id."""

    error: str = betterproto.string_field(3)
    """Error. Deprecated: replaced by items."""

    downlink_id: bytes = betterproto.bytes_field(4)
    """Downlink ID (UUID)."""

    items: List["DownlinkTxAckItem"] = betterproto.message_field(5)
    """
    Downlink frame items. This list has the same length as the request and
    indicates which downlink frame has been emitted of the requested list (or
    why it failed). Note that at most one item has a positive acknowledgement.
    """


@dataclass(eq=False, repr=False)
class DownlinkTxAckItem(betterproto.Message):
    status: "TxAckStatus" = betterproto.enum_field(1)
    """The Ack status of this item."""


@dataclass(eq=False, repr=False)
class GatewayConfiguration(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    version: str = betterproto.string_field(2)
    """Configuration version."""

    channels: List["ChannelConfiguration"] = betterproto.message_field(3)
    """Channels."""

    stats_interval: timedelta = betterproto.message_field(4)
    """Stats interval."""


@dataclass(eq=False, repr=False)
class ChannelConfiguration(betterproto.Message):
    frequency: int = betterproto.uint32_field(1)
    """Frequency (Hz)."""

    modulation: "_common__.Modulation" = betterproto.enum_field(2)
    """Channel modulation."""

    lora_modulation_config: "LoRaModulationConfig" = betterproto.message_field(
        3, group="modulation_config"
    )
    """LoRa modulation config."""

    fsk_modulation_config: "FskModulationConfig" = betterproto.message_field(
        4, group="modulation_config"
    )
    """FSK modulation config."""

    board: int = betterproto.uint32_field(5)
    """Board index."""

    demodulator: int = betterproto.uint32_field(6)
    """Demodulator index (of the given board)."""


@dataclass(eq=False, repr=False)
class LoRaModulationConfig(betterproto.Message):
    bandwidth: int = betterproto.uint32_field(1)
    """Bandwidth."""

    spreading_factors: List[int] = betterproto.uint32_field(2)
    """Spreading-factors."""


@dataclass(eq=False, repr=False)
class FskModulationConfig(betterproto.Message):
    bandwidth: int = betterproto.uint32_field(1)
    """Bandwidth."""

    bitrate: int = betterproto.uint32_field(2)
    """Bitrate."""


@dataclass(eq=False, repr=False)
class GatewayCommandExecRequest(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    command: str = betterproto.string_field(2)
    """
    Command to execute. This command must be pre-configured in the LoRa Gateway
    Bridge configuration.
    """

    exec_id: bytes = betterproto.bytes_field(3)
    """
    Execution request ID (UUID). The same token will be returned when the
    execution of the command has completed.
    """

    stdin: bytes = betterproto.bytes_field(4)
    """Standard input."""

    environment: Dict[str, str] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """Environment variables."""


@dataclass(eq=False, repr=False)
class GatewayCommandExecResponse(betterproto.Message):
    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    exec_id: bytes = betterproto.bytes_field(2)
    """Execution request ID (UUID)."""

    stdout: bytes = betterproto.bytes_field(3)
    """Standard output."""

    stderr: bytes = betterproto.bytes_field(4)
    """Standard error."""

    error: str = betterproto.string_field(5)
    """Error message."""


@dataclass(eq=False, repr=False)
class RawPacketForwarderEvent(betterproto.Message):
    """
    RawPacketForwarderEvent contains a raw packet-forwarder event. It can be
    used to access packet-forwarder features that are not (fully) integrated
    with the ChirpStack Gateway Bridge.
    """

    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    raw_id: bytes = betterproto.bytes_field(2)
    """Raw ID (UUID)."""

    payload: bytes = betterproto.bytes_field(3)
    """Payload contains the raw payload."""


@dataclass(eq=False, repr=False)
class RawPacketForwarderCommand(betterproto.Message):
    """
    RawPacketForwarderEvent contains a raw packet-forwarder command. It can be
    used to access packet-forwarder features that are not (fully) integrated
    with the ChirpStack Gateway Bridge.
    """

    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    raw_id: bytes = betterproto.bytes_field(2)
    """Raw ID (UUID)."""

    payload: bytes = betterproto.bytes_field(3)
    """Payload contains the raw payload."""


@dataclass(eq=False, repr=False)
class ConnState(betterproto.Message):
    """ConnState contains the connection state of a gateway."""

    gateway_id: bytes = betterproto.bytes_field(1)
    """Gateway ID."""

    state: "ConnStateState" = betterproto.enum_field(2)
