# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: chirpstack-api/fuota/fuota.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class MulticastGroupType(betterproto.Enum):
    CLASS_B = 0
    """Class-B."""

    CLASS_C = 1
    """Class-C."""


class RequestFragmentationSessionStatus(betterproto.Enum):
    AFTER_FRAGMENT_ENQUEUE = 0
    """
    Enqueue the fragmentation-session status request command directly after
    enqueueing the fragmentation-session fragments. This is the recommended
    option for Class-A devices as the status request will stay in the downlink
    queue until the device sends its next uplink.
    """

    AFTER_SESSION_TIMEOUT = 1
    """
    Enqueue the fragmentation-session status request after the multicast
    session-timeout. This is the recommended option for Class-B and -C devices
    as selecting AFTER_FRAGMENT_ENQUEUE will likely cause the NS to schedule
    the downlink frame during the FUOTA multicast-session.
    """

    NO_REQUEST = 2
    """Do not request the fragmentation-session status."""


@dataclass(eq=False, repr=False)
class DeploymentDevice(betterproto.Message):
    dev_eui: bytes = betterproto.bytes_field(1)
    """DevEUI."""

    mc_root_key: bytes = betterproto.bytes_field(2)
    """McRootKey."""


@dataclass(eq=False, repr=False)
class Deployment(betterproto.Message):
    application_id: int = betterproto.int64_field(1)
    """Application ID."""

    devices: List["DeploymentDevice"] = betterproto.message_field(2)
    """Devices to include in this deployment."""

    multicast_group_type: "MulticastGroupType" = betterproto.enum_field(3)
    """Multicast-group type."""

    multicast_dr: int = betterproto.uint32_field(4)
    """Multicast data-rate."""

    multicast_ping_slot_period: int = betterproto.uint32_field(5)
    """Multicast ping-slot period (Class-B only)."""

    multicast_frequency: int = betterproto.uint32_field(6)
    """Multicast frequency (Hz)."""

    multicast_group_id: int = betterproto.uint32_field(7)
    """Multicast group ID."""

    multicast_timeout: int = betterproto.uint32_field(8)
    """
    Multicast timeout. This defines the timeout of the multicast-session.
    Please refer to the Remote Multicast Setup specification as this field has
    a different meaning for Class-B and Class-C groups.
    """

    unicast_timeout: timedelta = betterproto.message_field(9)
    """
    Unicast timeout. Set this to the value in which you at least expect an
    uplink frame from the device. The FUOTA server will wait for the given time
    before attempting a retry or continuing with the next step.
    """

    unicast_attempt_count: int = betterproto.uint32_field(10)
    """
    Unicast attempt count. The number of attempts before considering an unicast
    command to be failed.
    """

    fragmentation_fragment_size: int = betterproto.uint32_field(11)
    """
    FragmentationFragmentSize. This defines the size of each payload fragment.
    Please refer to the Regional Parameters specification for the maximum
    payload sizes per data-rate and region.
    """

    payload: bytes = betterproto.bytes_field(12)
    """Payload."""

    fragmentation_redundancy: int = betterproto.uint32_field(13)
    """
    Fragmentation redundancy. The number represents the additional redundant
    frames to send.
    """

    fragmentation_session_index: int = betterproto.uint32_field(14)
    """Fragmentation session index."""

    fragmentation_matrix: int = betterproto.uint32_field(15)
    """Fragmentation matrix."""

    fragmentation_block_ack_delay: int = betterproto.uint32_field(16)
    """Block ack delay."""

    fragmentation_descriptor: bytes = betterproto.bytes_field(17)
    """Descriptor (4 bytes)."""

    request_fragmentation_session_status: "RequestFragmentationSessionStatus" = (
        betterproto.enum_field(18)
    )
    """Request fragmentation session status."""


@dataclass(eq=False, repr=False)
class CreateDeploymentRequest(betterproto.Message):
    deployment: "Deployment" = betterproto.message_field(1)
    """Deployment."""


@dataclass(eq=False, repr=False)
class CreateDeploymentResponse(betterproto.Message):
    id: bytes = betterproto.bytes_field(1)
    """ID of the created deployment."""


@dataclass(eq=False, repr=False)
class GetDeploymentStatusRequest(betterproto.Message):
    id: bytes = betterproto.bytes_field(1)
    """Deployment ID."""


@dataclass(eq=False, repr=False)
class DeploymentDeviceStatus(betterproto.Message):
    dev_eui: bytes = betterproto.bytes_field(1)
    """DevEUI."""

    created_at: datetime = betterproto.message_field(2)
    """Created at."""

    updated_at: datetime = betterproto.message_field(3)
    """Updated at."""

    mc_group_setup_completed_at: datetime = betterproto.message_field(4)
    """Multicast-group setup completed at."""

    mc_session_completed_at: datetime = betterproto.message_field(5)
    """Multicast-session completed at."""

    frag_session_setup_completed_at: datetime = betterproto.message_field(6)
    """Fragmentation session setup completed at."""

    frag_status_completed_at: datetime = betterproto.message_field(7)
    """Fragmentation status completed at."""


@dataclass(eq=False, repr=False)
class GetDeploymentStatusResponse(betterproto.Message):
    created_at: datetime = betterproto.message_field(1)
    """Created at."""

    updated_at: datetime = betterproto.message_field(2)
    """Updated at."""

    mc_group_setup_completed_at: datetime = betterproto.message_field(3)
    """Multicast-group setup completed at."""

    mc_session_completed_at: datetime = betterproto.message_field(4)
    """Multicast-session completed at."""

    frag_session_setup_completed_at: datetime = betterproto.message_field(5)
    """Fragmentation session setup completed at."""

    enqueue_completed_at: datetime = betterproto.message_field(6)
    """Enqueue completed at."""

    frag_status_completed_at: datetime = betterproto.message_field(7)
    """Fragmentation status completed at."""

    device_status: List["DeploymentDeviceStatus"] = betterproto.message_field(8)
    """Per device status."""


@dataclass(eq=False, repr=False)
class GetDeploymentDeviceLogsRequest(betterproto.Message):
    deployment_id: bytes = betterproto.bytes_field(1)
    """Deployment ID."""

    dev_eui: bytes = betterproto.bytes_field(2)
    """DevEUI."""


@dataclass(eq=False, repr=False)
class DeploymentDeviceLog(betterproto.Message):
    created_at: datetime = betterproto.message_field(1)
    """Created at."""

    f_port: int = betterproto.uint32_field(2)
    """FPort."""

    command: str = betterproto.string_field(3)
    """Command."""

    fields: Dict[str, str] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """Fields."""


@dataclass(eq=False, repr=False)
class GetDeploymentDeviceLogsResponse(betterproto.Message):
    logs: List["DeploymentDeviceLog"] = betterproto.message_field(1)


class FuotaServerServiceStub(betterproto.ServiceStub):
    async def create_deployment(
        self,
        create_deployment_request: "CreateDeploymentRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateDeploymentResponse":
        return await self._unary_unary(
            "/fuota.FUOTAServerService/CreateDeployment",
            create_deployment_request,
            CreateDeploymentResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_deployment_status(
        self,
        get_deployment_status_request: "GetDeploymentStatusRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDeploymentStatusResponse":
        return await self._unary_unary(
            "/fuota.FUOTAServerService/GetDeploymentStatus",
            get_deployment_status_request,
            GetDeploymentStatusResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_deployment_device_logs(
        self,
        get_deployment_device_logs_request: "GetDeploymentDeviceLogsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GetDeploymentDeviceLogsResponse":
        return await self._unary_unary(
            "/fuota.FUOTAServerService/GetDeploymentDeviceLogs",
            get_deployment_device_logs_request,
            GetDeploymentDeviceLogsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class FuotaServerServiceBase(ServiceBase):
    async def create_deployment(
        self, create_deployment_request: "CreateDeploymentRequest"
    ) -> "CreateDeploymentResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_deployment_status(
        self, get_deployment_status_request: "GetDeploymentStatusRequest"
    ) -> "GetDeploymentStatusResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_deployment_device_logs(
        self, get_deployment_device_logs_request: "GetDeploymentDeviceLogsRequest"
    ) -> "GetDeploymentDeviceLogsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_deployment(
        self,
        stream: "grpclib.server.Stream[CreateDeploymentRequest, CreateDeploymentResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_deployment(request)
        await stream.send_message(response)

    async def __rpc_get_deployment_status(
        self,
        stream: "grpclib.server.Stream[GetDeploymentStatusRequest, GetDeploymentStatusResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_deployment_status(request)
        await stream.send_message(response)

    async def __rpc_get_deployment_device_logs(
        self,
        stream: "grpclib.server.Stream[GetDeploymentDeviceLogsRequest, GetDeploymentDeviceLogsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_deployment_device_logs(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/fuota.FUOTAServerService/CreateDeployment": grpclib.const.Handler(
                self.__rpc_create_deployment,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateDeploymentRequest,
                CreateDeploymentResponse,
            ),
            "/fuota.FUOTAServerService/GetDeploymentStatus": grpclib.const.Handler(
                self.__rpc_get_deployment_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDeploymentStatusRequest,
                GetDeploymentStatusResponse,
            ),
            "/fuota.FUOTAServerService/GetDeploymentDeviceLogs": grpclib.const.Handler(
                self.__rpc_get_deployment_device_logs,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetDeploymentDeviceLogsRequest,
                GetDeploymentDeviceLogsResponse,
            ),
        }
